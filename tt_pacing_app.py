import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from io import StringIO, BytesIO
from course_speed import *  # your functions

st.title("Course Speed Optimization")

# File upload
uploaded_file = st.file_uploader("Upload GPX file", type=["gpx"])
if uploaded_file is not None:
    # Save uploaded file to a temp path or read directly
    gpx_bytes = uploaded_file.read()
    # Option 1: parse_gpx might accept a file-like or string, if not you may need to save temporarily
    # For now, let's write to a temporary file
    with open("temp.gpx", "wb") as f:
        f.write(gpx_bytes)
    gpx_path = "temp.gpx"

    # Input parameters
    fixed_avg_power = st.number_input("Fixed average power (W)", value=360, min_value=50, max_value=1000)
    VI = st.number_input("Variability Index (VI)", value=1.1, min_value=1.0, max_value=2.0, step=0.01)
    max_power = st.number_input("Max power per segment (W)", value=480, min_value=100, max_value=2000)
    cda = st.number_input("CdA (drag coefficient area)", value=0.24, format="%.3f")
    c_rr = st.number_input("Rolling resistance coefficient", value=0.003, format="%.4f")
    wind_direction = st.number_input("Wind direction (degrees)", value=90, min_value=0, max_value=360)
    wind_speed = st.number_input("Wind speed (m/s)", value=5.0, min_value=0.0, max_value=50.0, format="%.1f")
    mass_kg = st.number_input("Rider + bike mass (kg)", value=88, min_value=30, max_value=150)
    air_density = 1.225  # Fixed for now; could be another input if desired
    g = 9.81  # gravity constant

    if st.button("Run optimization"):
        # Parse GPX and segment
        df = parse_gpx(gpx_path)
        df, segments = segment_route_slope_then_wind(df, wind_direction, wind_speed=wind_speed)

        segment_ids = df['final_segment_id'].values
        unique_segments = np.unique(segment_ids)
        segment_labels_list = segments['segment_label'].tolist()

        # Run optimization
        optimized_powers, time_saved = optimize_segment_powers(
            gpx_path=gpx_path,
            segment_ids=segment_ids,
            fixed_avg_power=fixed_avg_power,
            VI=VI,
            max_power=max_power,
            mass_kg=mass_kg,
            cda=cda,
            c_rr=c_rr,
            wind_speed=wind_speed,
            wind_direction=wind_direction,
            air_density=air_density,
            g=g
        )

        power_per_segment_id = {seg: power for seg, power in zip(unique_segments, optimized_powers)}

        results = analyze_gpx_power_with_energy_segments(
            gpx_path,
            power_per_segment_id=power_per_segment_id,
            segment_ids=segment_ids,
            default_power=fixed_avg_power,
            c_rr=c_rr,
            cda=cda,
            mass_kg=mass_kg,
            wind_speed=wind_speed,
            wind_direction=wind_direction
        )

        # Show plots inline
        st.subheader("Route plot with segments")
        plot_route_2d_with_segments(df['lat'].values, df['lon'].values, df['final_segment_label'].values,
                                    wind_dir_deg=wind_direction, wind_speed=wind_speed)
        fig1 = plt.gcf()  # get current figure generated by the function
        st.pyplot(fig1)
        plt.close(fig1)   # close to free memory

        st.subheader("Power and Elevation by Segment")
        plot_power_and_elevation_by_segment(
            cum_dist=results["cumulative_distance"],
            elevation=results["elevation"],
            segments=segment_ids,
            powers=power_per_segment_id,
            segment_labels_list=segment_labels_list
        )
        fig2 = plt.gcf()
        st.pyplot(fig2)
        plt.close(fig2)

        # Display stats
        st.write(f"**Average speed:** {results['average_speed_m_s']:.2f} m/s ({results['average_speed_kmh']:.2f} km/h)")
        st.write(f"**Average power:** {results['average_power']:.2f} W")
        st.write(f"**Normalized power:** {results['normalized_power']:.2f} W")
        st.write(f"**Time saved compared to even pacing:** {time_saved:.2f} seconds")

else:
    st.info("Please upload a GPX file to begin.")
